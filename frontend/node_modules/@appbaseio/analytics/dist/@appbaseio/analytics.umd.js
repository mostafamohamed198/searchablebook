(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.aa = factory());
}(this, (function () { 'use strict';

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  // Function to parse the URL
  function btoa(input) {
    if (input === void 0) {
      input = '';
    }

    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var str = input;
    var output = ''; // eslint-disable-next-line

    for (var block = 0, charCode, i = 0, map = chars; str.charAt(i | 0) || (map = '=', i % 1); // eslint-disable-line no-bitwise
    output += map.charAt(63 & block >> 8 - i % 1 * 8) // eslint-disable-line no-bitwise
    ) {
      charCode = str.charCodeAt(i += 3 / 4);

      if (charCode > 0xff) {
        throw new Error('"btoa" failed: The string to be encoded contains characters outside of the Latin1 range.');
      }

      block = block << 8 | charCode; // eslint-disable-line no-bitwise
    }

    return output;
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var browserPonyfill = createCommonjsModule(function (module, exports) {
  var global = typeof self !== 'undefined' ? self : commonjsGlobal;
  var __self__ = (function () {
  function F() {
  this.fetch = false;
  this.DOMException = global.DOMException;
  }
  F.prototype = global;
  return new F();
  })();
  (function(self) {

  var irrelevant = (function (exports) {

    var support = {
      searchParams: 'URLSearchParams' in self,
      iterable: 'Symbol' in self && 'iterator' in Symbol,
      blob:
        'FileReader' in self &&
        'Blob' in self &&
        (function() {
          try {
            new Blob();
            return true
          } catch (e) {
            return false
          }
        })(),
      formData: 'FormData' in self,
      arrayBuffer: 'ArrayBuffer' in self
    };

    function isDataView(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    if (support.arrayBuffer) {
      var viewClasses = [
        '[object Int8Array]',
        '[object Uint8Array]',
        '[object Uint8ClampedArray]',
        '[object Int16Array]',
        '[object Uint16Array]',
        '[object Int32Array]',
        '[object Uint32Array]',
        '[object Float32Array]',
        '[object Float64Array]'
      ];

      var isArrayBufferView =
        ArrayBuffer.isView ||
        function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
        };
    }

    function normalizeName(name) {
      if (typeof name !== 'string') {
        name = String(name);
      }
      if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name')
      }
      return name.toLowerCase()
    }

    function normalizeValue(value) {
      if (typeof value !== 'string') {
        value = String(value);
      }
      return value
    }

    // Build a destructive iterator for the value list
    function iteratorFor(items) {
      var iterator = {
        next: function() {
          var value = items.shift();
          return {done: value === undefined, value: value}
        }
      };

      if (support.iterable) {
        iterator[Symbol.iterator] = function() {
          return iterator
        };
      }

      return iterator
    }

    function Headers(headers) {
      this.map = {};

      if (headers instanceof Headers) {
        headers.forEach(function(value, name) {
          this.append(name, value);
        }, this);
      } else if (Array.isArray(headers)) {
        headers.forEach(function(header) {
          this.append(header[0], header[1]);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function(name) {
          this.append(name, headers[name]);
        }, this);
      }
    }

    Headers.prototype.append = function(name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue + ', ' + value : value;
    };

    Headers.prototype['delete'] = function(name) {
      delete this.map[normalizeName(name)];
    };

    Headers.prototype.get = function(name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null
    };

    Headers.prototype.has = function(name) {
      return this.map.hasOwnProperty(normalizeName(name))
    };

    Headers.prototype.set = function(name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };

    Headers.prototype.forEach = function(callback, thisArg) {
      for (var name in this.map) {
        if (this.map.hasOwnProperty(name)) {
          callback.call(thisArg, this.map[name], name, this);
        }
      }
    };

    Headers.prototype.keys = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push(name);
      });
      return iteratorFor(items)
    };

    Headers.prototype.values = function() {
      var items = [];
      this.forEach(function(value) {
        items.push(value);
      });
      return iteratorFor(items)
    };

    Headers.prototype.entries = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items)
    };

    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }

    function consumed(body) {
      if (body.bodyUsed) {
        return Promise.reject(new TypeError('Already read'))
      }
      body.bodyUsed = true;
    }

    function fileReaderReady(reader) {
      return new Promise(function(resolve, reject) {
        reader.onload = function() {
          resolve(reader.result);
        };
        reader.onerror = function() {
          reject(reader.error);
        };
      })
    }

    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise
    }

    function readBlobAsText(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsText(blob);
      return promise
    }

    function readArrayBufferAsText(buf) {
      var view = new Uint8Array(buf);
      var chars = new Array(view.length);

      for (var i = 0; i < view.length; i++) {
        chars[i] = String.fromCharCode(view[i]);
      }
      return chars.join('')
    }

    function bufferClone(buf) {
      if (buf.slice) {
        return buf.slice(0)
      } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer
      }
    }

    function Body() {
      this.bodyUsed = false;

      this._initBody = function(body) {
        this._bodyInit = body;
        if (!body) {
          this._bodyText = '';
        } else if (typeof body === 'string') {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
          this._bodyArrayBuffer = bufferClone(body.buffer);
          // IE 10-11 can't handle a DataView body.
          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
          this._bodyArrayBuffer = bufferClone(body);
        } else {
          this._bodyText = body = Object.prototype.toString.call(body);
        }

        if (!this.headers.get('content-type')) {
          if (typeof body === 'string') {
            this.headers.set('content-type', 'text/plain;charset=UTF-8');
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set('content-type', this._bodyBlob.type);
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
          }
        }
      };

      if (support.blob) {
        this.blob = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected
          }

          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob)
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(new Blob([this._bodyArrayBuffer]))
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob')
          } else {
            return Promise.resolve(new Blob([this._bodyText]))
          }
        };

        this.arrayBuffer = function() {
          if (this._bodyArrayBuffer) {
            return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
          } else {
            return this.blob().then(readBlobAsArrayBuffer)
          }
        };
      }

      this.text = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      };

      if (support.formData) {
        this.formData = function() {
          return this.text().then(decode)
        };
      }

      this.json = function() {
        return this.text().then(JSON.parse)
      };

      return this
    }

    // HTTP methods whose capitalization should be normalized
    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return methods.indexOf(upcased) > -1 ? upcased : method
    }

    function Request(input, options) {
      options = options || {};
      var body = options.body;

      if (input instanceof Request) {
        if (input.bodyUsed) {
          throw new TypeError('Already read')
        }
        this.url = input.url;
        this.credentials = input.credentials;
        if (!options.headers) {
          this.headers = new Headers(input.headers);
        }
        this.method = input.method;
        this.mode = input.mode;
        this.signal = input.signal;
        if (!body && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }
      } else {
        this.url = String(input);
      }

      this.credentials = options.credentials || this.credentials || 'same-origin';
      if (options.headers || !this.headers) {
        this.headers = new Headers(options.headers);
      }
      this.method = normalizeMethod(options.method || this.method || 'GET');
      this.mode = options.mode || this.mode || null;
      this.signal = options.signal || this.signal;
      this.referrer = null;

      if ((this.method === 'GET' || this.method === 'HEAD') && body) {
        throw new TypeError('Body not allowed for GET or HEAD requests')
      }
      this._initBody(body);
    }

    Request.prototype.clone = function() {
      return new Request(this, {body: this._bodyInit})
    };

    function decode(body) {
      var form = new FormData();
      body
        .trim()
        .split('&')
        .forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split('=');
            var name = split.shift().replace(/\+/g, ' ');
            var value = split.join('=').replace(/\+/g, ' ');
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
      return form
    }

    function parseHeaders(rawHeaders) {
      var headers = new Headers();
      // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
      // https://tools.ietf.org/html/rfc7230#section-3.2
      var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
      preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
        var parts = line.split(':');
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
      return headers
    }

    Body.call(Request.prototype);

    function Response(bodyInit, options) {
      if (!options) {
        options = {};
      }

      this.type = 'default';
      this.status = options.status === undefined ? 200 : options.status;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = 'statusText' in options ? options.statusText : 'OK';
      this.headers = new Headers(options.headers);
      this.url = options.url || '';
      this._initBody(bodyInit);
    }

    Body.call(Response.prototype);

    Response.prototype.clone = function() {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      })
    };

    Response.error = function() {
      var response = new Response(null, {status: 0, statusText: ''});
      response.type = 'error';
      return response
    };

    var redirectStatuses = [301, 302, 303, 307, 308];

    Response.redirect = function(url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError('Invalid status code')
      }

      return new Response(null, {status: status, headers: {location: url}})
    };

    exports.DOMException = self.DOMException;
    try {
      new exports.DOMException();
    } catch (err) {
      exports.DOMException = function(message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
      };
      exports.DOMException.prototype = Object.create(Error.prototype);
      exports.DOMException.prototype.constructor = exports.DOMException;
    }

    function fetch(input, init) {
      return new Promise(function(resolve, reject) {
        var request = new Request(input, init);

        if (request.signal && request.signal.aborted) {
          return reject(new exports.DOMException('Aborted', 'AbortError'))
        }

        var xhr = new XMLHttpRequest();

        function abortXhr() {
          xhr.abort();
        }

        xhr.onload = function() {
          var options = {
            status: xhr.status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
          };
          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
          var body = 'response' in xhr ? xhr.response : xhr.responseText;
          resolve(new Response(body, options));
        };

        xhr.onerror = function() {
          reject(new TypeError('Network request failed'));
        };

        xhr.ontimeout = function() {
          reject(new TypeError('Network request failed'));
        };

        xhr.onabort = function() {
          reject(new exports.DOMException('Aborted', 'AbortError'));
        };

        xhr.open(request.method, request.url, true);

        if (request.credentials === 'include') {
          xhr.withCredentials = true;
        } else if (request.credentials === 'omit') {
          xhr.withCredentials = false;
        }

        if ('responseType' in xhr && support.blob) {
          xhr.responseType = 'blob';
        }

        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });

        if (request.signal) {
          request.signal.addEventListener('abort', abortXhr);

          xhr.onreadystatechange = function() {
            // DONE (success or failure)
            if (xhr.readyState === 4) {
              request.signal.removeEventListener('abort', abortXhr);
            }
          };
        }

        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
      })
    }

    fetch.polyfill = true;

    if (!self.fetch) {
      self.fetch = fetch;
      self.Headers = Headers;
      self.Request = Request;
      self.Response = Response;
    }

    exports.Headers = Headers;
    exports.Request = Request;
    exports.Response = Response;
    exports.fetch = fetch;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

  })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  // Remove "polyfill" property added by whatwg-fetch
  delete __self__.fetch.polyfill;
  // Choose between native implementation (global) or custom implementation (__self__)
  // var ctx = global.fetch ? global : __self__;
  var ctx = __self__; // this line disable service worker support temporarily
  exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'
  exports.default = ctx.fetch; // For TypeScript consumers without esModuleInterop.
  exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'
  exports.Headers = ctx.Headers;
  exports.Request = ctx.Request;
  exports.Response = ctx.Response;
  module.exports = exports;
  });

  var fetch = unwrapExports(browserPonyfill);
  var browserPonyfill_1 = browserPonyfill.fetch;
  var browserPonyfill_2 = browserPonyfill.Headers;
  var browserPonyfill_3 = browserPonyfill.Request;
  var browserPonyfill_4 = browserPonyfill.Response;

  function validateIndex(index) {
    if (!index) {
      throw new Error('appbase-analytics: A valid index must be present to record analytics events.');
    }
  }
  function validateCredentials(credentials) {
    if (!credentials) {
      throw new Error('appbase-analytics: Auth credentials is missing.');
    }
  }
  function validateURL(url) {
    if (!url) {
      throw new Error('appbase-analytics: URL is missing.');
    }
  }
  function validateQuery(query, queryID) {
    if ((query === undefined || query === null) && !queryID) {
      throw new Error('appbase-analytics: query or queryID must be present to register a click/conversion event');
    }
  }
  function validateQueryID(queryID) {
    if (!queryID) {
      throw new Error('appbase-analytics: queryID must be present to save search/favorite');
    }
  }
  function validateClickObjects(objects) {
    if (!objects || Object.keys(objects).length < 1) {
      throw new Error('appbase-analytics: at least one click object must be present to register a click event');
    }
  }
  function validateConversionObjects(objects) {
    if (!objects || Object.keys(objects).length < 1) {
      throw new Error('appbase-analytics: at least one click object must be present to register a click event');
    }
  }

  function initClient(config) {
    if (config === void 0) {
      config = {};
    }

    var metrics = {
      credentials: config.credentials,
      index: config.index,
      url: config.url,
      userID: config.userID,
      globalCustomEvents: config.globalCustomEvents,
      queryID: '',
      headers: null,
      _request: function _request(method, url, body, queryParams, callback) {
        var finalBody = _extends({
          user_id: metrics.userID
        }, body, {
          custom_events: _extends({}, body && body.custom_events, {}, metrics.globalCustomEvents)
        });

        var queryParamsString = '';

        if (queryParams) {
          queryParamsString = Object.keys(queryParams).map(function (param) {
            return param + "=" + queryParams[param];
          }).join('&');
        }

        return fetch(metrics.url + "/" + url + "?" + queryParamsString, {
          method: method,
          headers: _extends({}, metrics.headers, {
            'Content-Type': 'application/json',
            Authorization: "Basic " + btoa(metrics.credentials)
          }),
          body: method === 'GET' ? null : JSON.stringify(finalBody)
        }).then(function (response) {
          if (callback) {
            callback(null, response);
          }
        })["catch"](function (err) {
          if (callback) {
            callback(err, null);
          }
        });
      }
    };
    validateIndex(metrics.index);
    validateCredentials(metrics.credentials);
    validateURL(metrics.url); // To register a search

    metrics.search = function (searchConfig, callback) {
      validateQuery(searchConfig.query, searchConfig.queryID);

      var captureQueryID = function captureQueryID(err, res) {
        if (res) {
          res.json().then(function (response) {
            if (response && response.query_id) {
              metrics.queryID = response.query_id;
            }

            if (callback) {
              callback(err, res);
            }
          })["catch"](function (err2) {
            if (callback) {
              callback(err2, res);
            }
          });
        } else if (callback) {
          callback(err, res);
        }
      }; // just to avoid the flow type error


      if (metrics._request) {
        var requestBody = {
          query: searchConfig.query,
          query_id: searchConfig.queryID,
          custom_events: searchConfig.customEvents,
          filters: searchConfig.filters,
          hits: searchConfig.hits,
          impressions: searchConfig.impressions
        };

        metrics._request('PUT', metrics.index + "/_analytics/search", requestBody, null, captureQueryID);
      }
    }; // To register a click


    metrics.click = function (clickConfig, callback) {
      validateQuery(clickConfig.query, clickConfig.queryID);
      validateClickObjects(clickConfig.objects); // just to avoid the flow type error

      if (metrics._request) {
        var requestBody = {
          click_on: clickConfig.objects,
          click_type: clickConfig.isSuggestionClick ? 'suggestion' : 'result',
          query: clickConfig.query,
          query_id: clickConfig.queryID,
          custom_events: clickConfig.customEvents,
          meta: clickConfig.meta
        };

        metrics._request('PUT', metrics.index + "/_analytics/click", requestBody, null, callback);
      }
    }; // To register a conversion


    metrics.conversion = function (conversionConfig, callback) {
      validateQuery(null, conversionConfig.queryID);
      validateConversionObjects(conversionConfig.objects); // just to avoid the flow type error

      if (metrics._request) {
        var requestBody = {
          conversion_on: conversionConfig.objects,
          query_id: conversionConfig.queryID,
          meta: conversionConfig.meta
        };

        metrics._request('PUT', metrics.index + "/_analytics/conversion", requestBody, null, callback);
      }
    }; // To save search


    metrics.saveSearch = function (saveSearchConfig, callback) {
      validateQueryID(saveSearchConfig.queryID);
      var requestBody = {
        query_id: saveSearchConfig.queryID,
        save_search_id: saveSearchConfig.saveSearchID,
        save_search_meta: saveSearchConfig.saveSearchMeta,
        user_id: saveSearchConfig.userID,
        custom_events: saveSearchConfig.customEvents
      };

      metrics._request('PUT', '_analytics/save-search', requestBody, null, callback);
    }; // To delete save search


    metrics.deleteSavedSearch = function (saveSearchId, callback) {
      metrics._request('DELETE', '_analytics/save-search/' + saveSearchId, null, null, callback);
    }; // To retrieve saved searches


    metrics.getSavedSearches = function (filters, callback) {
      // just to avoid the flow type error
      if (metrics._request) {
        metrics._request('GET', '_analytics/saved-searches', null, filters, callback);
      }
    }; // To record a favorite document


    metrics.favorite = function (favoriteConfig, callback) {
      validateQueryID(favoriteConfig.queryID);

      if (!favoriteConfig.favoriteOn || favoriteConfig.favoriteOn === '') {
        throw new Error('appbase-analytics: favoriteOn property is required');
      }

      if (!favoriteConfig.source) {
        throw new Error('appbase-analytics: source property is required');
      }

      var requestBody = {
        query_id: favoriteConfig.queryID,
        favorite_on: favoriteConfig.favoriteOn,
        source: favoriteConfig.source,
        id: favoriteConfig.id,
        meta: favoriteConfig.meta,
        user_id: favoriteConfig.userID,
        custom_events: favoriteConfig.customEvents
      };

      metrics._request('PUT', '_analytics/favorite', requestBody, null, callback);
    }; // To retrieve favorites


    metrics.getFavorites = function (filters, callback) {
      // just to avoid the flow type error
      if (metrics._request) {
        metrics._request('GET', '_analytics/favorites', null, filters, callback);
      }
    }; // Sets the userID


    metrics.setUserID = function (userID) {
      metrics.userID = userID;
    }; // Sets the global events


    metrics.setGlobalCustomEvents = function (globalEvents) {
      metrics.globalCustomEvents = globalEvents;
    }; // Sets the headers


    metrics.setHeaders = function (headers) {
      metrics.headers = headers;
    }; // get queryID


    metrics.getQueryID = function () {
      return metrics.queryID;
    };

    return metrics;
  }

  var index = {
    init: initClient
  };

  return index;

})));
//# sourceMappingURL=analytics.umd.js.map
