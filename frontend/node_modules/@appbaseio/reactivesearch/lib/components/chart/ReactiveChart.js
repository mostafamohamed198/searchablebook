'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _echartsForReact = require('echarts-for-react');

var _echartsForReact2 = _interopRequireDefault(_echartsForReact);

var _types = require('@appbaseio/reactivecore/lib/utils/types');

var _types2 = _interopRequireDefault(_types);

var _propTypes = require('prop-types');

var _hoistNonReactStatics = require('hoist-non-react-statics');

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _actions = require('@appbaseio/reactivecore/lib/actions');

var _transform = require('@appbaseio/reactivecore/lib/utils/transform');

var _constants = require('@appbaseio/reactivecore/lib/utils/constants');

var _helper = require('@appbaseio/reactivecore/lib/utils/helper');

var _utils = require('../../utils');

var _PreferencesConsumer = require('../basic/PreferencesConsumer');

var _PreferencesConsumer2 = _interopRequireDefault(_PreferencesConsumer);

var _ComponentWrapper = require('../basic/ComponentWrapper');

var _ComponentWrapper2 = _interopRequireDefault(_ComponentWrapper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var getLoading = function getLoading(loading) {
	return loading === undefined ? true : loading;
};
var ChartTypes = {
	Pie: 'pie',
	Scatter: 'scatter',
	Histogram: 'histogram',
	Line: 'line',
	Bar: 'bar',
	Custom: 'custom'
};

var ReactiveChart = function (_React$Component) {
	_inherits(ReactiveChart, _React$Component);

	function ReactiveChart(props) {
		_classCallCheck(this, ReactiveChart);

		var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

		_initialiseProps.call(_this);

		var defaultValue = props.value;
		var currentValue = props.selectedValue || defaultValue;
		var options = _this.transformOptions(props.options, props);

		_this.state = {
			currentValue: currentValue,
			options: options
		};
		_this.internalComponent = (0, _transform.getInternalComponentID)(props.componentId);
		// Set custom and default queries in store
		(0, _helper.updateCustomQuery)(props.componentId, props, currentValue);
		(0, _helper.updateDefaultQuery)(_this.internalComponent, props, currentValue);

		_this.updateQueryOptions(props, false);
		if (currentValue) {
			_this.setValue(currentValue, true, props);
		}
		_this.setReact(props, _this.internalComponent);
		_this.handleRange = (0, _helper.debounce)(_this.handleRange, 100);

		if (props.chartType === ChartTypes.Custom) {
			if (typeof props.defaultQuery !== 'function' || typeof props.setOption !== 'function') {
				throw new Error('defaultQuery and setOption should be defined when chartType is custom');
			}
			if (props.useAsFilter && typeof props.customQuery !== 'function') {
				throw new Error('customQuery should be defined when chartType is custom and useAsFilter is true');
			}
		}
		return _this;
	}

	ReactiveChart.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
		var _this2 = this;

		if (!(0, _helper.isEqual)(prevProps.options, this.props.options)) {
			// set options in state
			// eslint-disable-next-line
			this.setState({
				options: this.transformOptions(this.props.options, this.props)
			});
		}
		(0, _helper.checkSomePropChange)(this.props, prevProps, ['dataField', 'aggregationSize'], function () {
			_this2.updateDefaultQuery();
			_this2.updateQuery(_this2.state.currentValue, _this2.props);
		});
		if (!(0, _utils.isQueryIdentical)(this.state.currentValue, this.props, prevProps, 'defaultQuery')) {
			this.updateDefaultQuery();
			// Clear the component value
			this.updateQuery('', this.props);
		}

		if (!(0, _utils.isQueryIdentical)(this.state.currentValue, this.props, prevProps, 'customQuery')) {
			this.updateQuery(this.state.currentValue, this.props);
		}

		if (this.props.value !== prevProps.value) {
			this.setValue(this.props.value);
		} else if (this.state.currentValue !== this.props.selectedValue && this.props.selectedValue !== prevProps.selectedValue) {
			var _props = this.props,
			    value = _props.value,
			    onChange = _props.onChange;

			if (value === undefined) {
				this.setValue(this.props.selectedValue);
			} else if (onChange) {
				onChange(this.props.selectedValue);
			} else {
				this.setValue(this.state.currentValue, true);
			}
		}
	};

	ReactiveChart.prototype.transformOptions = function transformOptions(options, props) {
		return (props.options && props.options[props.dataField] ? props.options[props.dataField].buckets : []).filter(function (item) {
			return !!String(item.key).length;
		});
	};

	ReactiveChart.prototype.render = function render() {
		var _props2 = this.props,
		    onDblClick = _props2.onDblClick,
		    onMouseDown = _props2.onMouseDown,
		    onMouseUp = _props2.onMouseUp,
		    onMouseMove = _props2.onMouseMove,
		    onMouseOut = _props2.onMouseOut,
		    onGlobalOut = _props2.onGlobalOut,
		    onContextMenu = _props2.onContextMenu,
		    isLoading = _props2.isLoading,
		    error = _props2.error,
		    loader = _props2.loader,
		    renderError = _props2.renderError;

		if (isLoading) {
			return loader || null;
		}
		if (error) {
			if (renderError) {
				if ((0, _helper.isFunction)(renderError)) {
					return renderError(error);
				}
				return renderError;
			}
			return null;
		}
		return _react2.default.createElement(_echartsForReact2.default, {
			option: this.getChartOptions(),
			onEvents: {
				click: this.handleClick,
				dblclick: onDblClick,
				mousedown: onMouseDown,
				mouseup: onMouseUp,
				mousemove: onMouseMove,
				mouseout: onMouseOut,
				globalout: onGlobalOut,
				contextmenu: onContextMenu,
				datazoom: this.handleRange
			},
			notMerge: true
		});
	};

	return ReactiveChart;
}(_react2.default.Component);

var _initialiseProps = function _initialiseProps() {
	var _this3 = this;

	this.setReact = function (props, componentId) {
		var react = props.react;

		if (react) {
			var newReact = (0, _helper.pushToAndClause)(react, _this3.internalComponent);
			props.watchComponent(componentId, newReact);
		} else {
			props.watchComponent(componentId, {
				and: _this3.internalComponent
			});
		}
	};

	this.updateDefaultQuery = function (queryOptions) {
		var props = _this3.props;
		var value = void 0;
		if (props.type === 'range') {
			value = (0, _utils.getNumericRangeArray)(props.range, props.queryFormat);
		}
		(0, _helper.updateInternalQuery)(_this3.internalComponent, queryOptions, value, _this3.props, ReactiveChart.generateQueryOptions(_this3.props, _this3.state.prevAfter, value), null);
	};

	this.updateQueryOptions = function (props) {
		var addAfterKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

		var queryOptions = ReactiveChart.generateQueryOptions(props, addAfterKey ? _this3.state.after : {}, _this3.state.currentValue);

		_this3.updateDefaultQuery(queryOptions);
	};

	this.handleClick = function () {
		var _props3 = _this3.props,
		    onClick = _props3.onClick,
		    useAsFilter = _props3.useAsFilter,
		    chartType = _props3.chartType,
		    type = _props3.type;

		if (onClick) {
			onClick.apply(undefined, arguments);
		}
		if (useAsFilter && type !== 'range') {
			var item = arguments.length <= 0 ? undefined : arguments[0];
			var value = void 0;
			if (item.data && item.data.name) {
				value = item.data.name;
			} else {
				value = item.data;
			}
			if (!Number.isNaN(parseInt(value, 10))) {
				value = parseInt(value, 10);
			}
			if (chartType === ChartTypes.Custom) {
				value = {
					mainLabel: item.name,
					secondaryLabel: item.seriesName,
					data: item.data
				};
			}
			_this3.setValue(value);
		}
	};

	this.updateQuery = function (value, props) {
		var execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
		var customQuery = props.customQuery;

		var query = ReactiveChart.defaultQuery(value, props);
		var customQueryOptions = void 0;
		if (customQuery) {
			(0, _helper.updateCustomQuery)(props.componentId, props, value);
		}
		props.setQueryOptions(props.componentId, _extends({}, ReactiveChart.generateQueryOptions(props, _this3.state.prevAfter, _this3.state.currentValue), customQueryOptions), false);
		props.updateQuery({
			componentId: props.componentId,
			query: query,
			value: value,
			label: props.filterLabel,
			showFilter: props.showFilter,
			URLParams: props.URLParams,
			componentType: _constants.componentTypes.reactiveChart
		}, execute, false);
	};

	this.setValue = function (value) {
		var isDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
		var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _this3.props;

		var performUpdate = function performUpdate() {
			var handleUpdates = function handleUpdates() {
				_this3.updateQuery(value, props);
			};
			_this3.setState({
				currentValue: value
			}, handleUpdates);
		};
		if (isDefault) {
			_this3.updateQuery(value, props, false, false);
		} else {
			(0, _helper.checkValueChange)(props.componentId, value, props.beforeValueChange, performUpdate);
		}
	};

	this.getChartOptions = function () {
		var _props4 = _this3.props,
		    chartType = _props4.chartType,
		    title = _props4.title,
		    labelFormatter = _props4.labelFormatter,
		    xAxisName = _props4.xAxisName,
		    yAxisName = _props4.yAxisName,
		    rawData = _props4.rawData,
		    hits = _props4.hits,
		    xAxisField = _props4.xAxisField,
		    yAxisField = _props4.yAxisField,
		    type = _props4.type;
		var _state = _this3.state,
		    options = _state.options,
		    currentValue = _state.currentValue;
		var setOption = _this3.props.setOption;

		var results = (0, _helper.parseHits)(hits) || [];
		var chartOptions = {
			aggregationData: options,
			rawData: rawData,
			value: currentValue,
			data: results,
			xAxisField: xAxisField,
			yAxisField: yAxisField,
			chartType: chartType,
			title: title,
			labelFormatter: labelFormatter,
			xAxisName: xAxisName,
			yAxisName: yAxisName,
			type: type
		};
		if (setOption) {
			return setOption(chartOptions);
		}
		return ReactiveChart.getOption(chartOptions);
	};

	this.handleRange = function () {
		var _props5 = _this3.props,
		    useAsFilter = _props5.useAsFilter,
		    onDataZoom = _props5.onDataZoom;

		if (useAsFilter) {
			var echartInstance = arguments.length <= 1 ? undefined : arguments[1];
			var axis = echartInstance.getModel().option.xAxis[0];
			var option = echartInstance.getOption();
			var start = option.dataZoom[0].startValue;
			var end = option.dataZoom[0].endValue;
			var startRangeValue = axis.data[start];
			var endRangeValue = axis.data[end];
			var rangeValue = [startRangeValue.value !== undefined ? startRangeValue.value : startRangeValue, endRangeValue.value !== undefined ? endRangeValue.value : endRangeValue];
			_this3.setValue(rangeValue);
		}
		if (onDataZoom) {
			onDataZoom.apply(undefined, arguments);
		}
	};
};

ReactiveChart.generateQueryOptions = function (props, after) {
	var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	var queryOptions = (0, _helper.getQueryOptions)(props);
	return (0, _helper.getAggsQuery)(value, queryOptions, props);
};

ReactiveChart.defaultQuery = function (value, props) {
	return {
		query: {
			queryFormat: props.queryFormat,
			dataField: props.dataField,
			value: value,
			nestedField: props.nestedField
		}
	};
};

ReactiveChart.GetScatterChartOptions = '({\n\tdata,\n\ttitle,\n\txAxisName,\n\tyAxisName,\n\txAxisField,\n\tyAxisField,\n}) => {\n\tlet chartTitle;\n\tif (title) {\n\t\tif (typeof title === \'string\') {\n\t\t\tchartTitle = {\n\t\t\t\ttext: title,\n\t\t\t};\n\t\t} else {\n\t\t\tchartTitle = title;\n\t\t}\n\t}\n\treturn {\n\t\ttitle: chartTitle,\n\t\ttooltip: {\n\t\t\ttrigger: \'item\',\n\t\t},\n\t\txAxis: {\n\t\t\tname: xAxisName,\n\t\t},\n\t\tyAxis: {\n\t\t\tname: yAxisName,\n\t\t},\n\t\tseries: [\n\t\t\t{\n\t\t\t\tsymbolSize: 20,\n\t\t\t\tdata: data.map(d => [d[xAxisField], d[yAxisField]]),\n\t\t\t\ttype: \'scatter\',\n\t\t\t},\n\t\t],\n\t};\n}';

ReactiveChart.GetPieChartOptions = '({ title, aggregationData }) => {\n\tlet chartTitle;\n\tif (title) {\n\t\tif (typeof title === \'string\') {\n\t\t\tchartTitle = {\n\t\t\t\ttext: title,\n\t\t\t\tleft: \'center\',\n\t\t\t};\n\t\t} else {\n\t\t\tchartTitle = title;\n\t\t}\n\t}\n\treturn {\n\t\ttitle: chartTitle,\n\t\ttooltip: {\n\t\t\ttrigger: \'item\',\n\t\t},\n\t\tseries: [\n\t\t\t{\n\t\t\t\ttype: \'pie\',\n\t\t\t\tradius: \'50%\',\n\t\t\t\tdata: aggregationData.map(item => ({\n\t\t\t\t\tvalue: item.doc_count,\n\t\t\t\t\tname: item.key,\n\t\t\t\t})),\n\t\t\t\temphasis: {\n\t\t\t\t\titemStyle: {\n\t\t\t\t\t\tshadowBlur: 10,\n\t\t\t\t\t\tshadowOffsetX: 0,\n\t\t\t\t\t\tshadowColor: \'rgba(0, 0, 0, 0.5)\',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t};\n}';

ReactiveChart.GetHistogramChartOptions = '({\n\ttitle,\n\txAxisName,\n\tyAxisName,\n\taggregationData,\n\tvalue,\n\tlabelFormatter,\n}) => {\n\tlet chartTitle;\n\tif (title) {\n\t\tif (typeof title === \'string\') {\n\t\t\tchartTitle = {\n\t\t\t\ttext: title,\n\t\t\t};\n\t\t} else {\n\t\t\tchartTitle = title;\n\t\t}\n\t}\n\tconst xAxisData = aggregationData.map(item => ({\n\t\tvalue: item.key,\n\t\tname: item.key,\n\t}));\n\tlet startIndex = -1;\n\tlet endIndex = -1;\n\tif (value && Array.isArray(value)) {\n\t\tstartIndex = xAxisData.findIndex(i => i.value === value[0]);\n\t\tendIndex = xAxisData.findIndex(i => i.value === value[1]);\n\t}\n\treturn {\n\t\ttitle: chartTitle,\n\t\ttoolbox: {\n\t\t\tfeature: {\n\t\t\t\tdataZoom: {\n\t\t\t\t\tyAxisIndex: false,\n\t\t\t\t\tlabelFormatter,\n\t\t\t\t},\n\t\t\t\tsaveAsImage: {\n\t\t\t\t\tpixelRatio: 2,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\ttooltip: {\n\t\t\ttrigger: \'axis\',\n\t\t\taxisPointer: {\n\t\t\t\ttype: \'shadow\',\n\t\t\t},\n\t\t},\n\t\tgrid: {\n\t\t\tbottom: 90,\n\t\t},\n\t\tdataZoom: [\n\t\t\t{\n\t\t\t\ttype: \'inside\',\n\t\t\t\tstartValue: startIndex > -1 ? startIndex : undefined,\n\t\t\t\tendValue: endIndex > -1 ? endIndex : undefined,\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: \'slider\',\n\t\t\t\tstartValue: startIndex > -1 ? startIndex : undefined,\n\t\t\t\tendValue: endIndex > -1 ? endIndex : undefined,\n\t\t\t},\n\t\t],\n\t\txAxis: {\n\t\t\tdata: xAxisData,\n\t\t\tname: xAxisName,\n\t\t\tsilent: false,\n\t\t\tsplitLine: {\n\t\t\t\tshow: false,\n\t\t\t},\n\t\t\tsplitArea: {\n\t\t\t\tshow: false,\n\t\t\t},\n\t\t},\n\t\tyAxis: {\n\t\t\tsplitArea: {\n\t\t\t\tshow: false,\n\t\t\t},\n\t\t\tname: yAxisName,\n\t\t},\n\t\tseries: [\n\t\t\t{\n\t\t\t\ttype: \'bar\',\n\t\t\t\tdata: aggregationData.map(item => ({\n\t\t\t\t\tvalue: item.doc_count,\n\t\t\t\t})),\n\t\t\t\t// Set \'large\' for large data amount\n\t\t\t\tlarge: true,\n\t\t\t},\n\t\t],\n\t};\n}';

ReactiveChart.GetBarChartOptions = '({\n\ttitle, xAxisName, yAxisName, aggregationData,\n}) => {\n\tlet chartTitle;\n\tif (title) {\n\t\tif (typeof title === \'string\') {\n\t\t\tchartTitle = {\n\t\t\t\ttext: title,\n\t\t\t};\n\t\t} else {\n\t\t\tchartTitle = title;\n\t\t}\n\t}\n\treturn {\n\t\ttitle: chartTitle,\n\t\ttooltip: {\n\t\t\ttrigger: \'item\',\n\t\t},\n\t\txAxis: {\n\t\t\ttype: \'category\',\n\t\t\tname: xAxisName,\n\t\t\tdata: aggregationData.map(item => ({\n\t\t\t\tvalue: item.key,\n\t\t\t\tname: item.key,\n\t\t\t})),\n\t\t},\n\t\tyAxis: {\n\t\t\ttype: \'value\',\n\t\t\tname: yAxisName,\n\t\t},\n\t\tseries: [\n\t\t\t{\n\t\t\t\tdata: aggregationData.map(item => ({\n\t\t\t\t\tvalue: item.doc_count,\n\t\t\t\t\tname: item.key,\n\t\t\t\t})),\n\t\t\t\ttype: \'bar\',\n\t\t\t\tshowBackground: true,\n\t\t\t\tbackgroundStyle: {\n\t\t\t\t\tcolor: \'rgba(180, 180, 180, 0.2)\',\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t};\n}';

ReactiveChart.GetLineChartOptions = '({\n\ttitle,\n\ttype,\n\tvalue,\n\txAxisName,\n\tyAxisName,\n\taggregationData,\n\tlabelFormatter,\n}) => {\n\tlet chartTitle;\n\n\tif (title) {\n\t\tif (typeof title === \'string\') {\n\t\t\tchartTitle = {\n\t\t\t\ttext: title,\n\t\t\t};\n\t\t} else {\n\t\t\tchartTitle = title;\n\t\t}\n\t}\n\tconst xAxisData = aggregationData.map(item => ({\n\t\tvalue: item.key,\n\t\tname: item.key,\n\t}));\n\n\tlet startIndex = -1;\n\tlet endIndex = -1;\n\tconst isValueArray = value && Array.isArray(value);\n\tconst isRangeType = type === \'range\';\n\tif (isValueArray && isRangeType) {\n\t\tstartIndex = xAxisData.findIndex(i => i.value === value[0]);\n\t\tendIndex = xAxisData.findIndex(i => i.value === value[1]);\n\t}\n\n\treturn {\n\t\ttitle: chartTitle,\n\t\ttoolbox: isRangeType ? {\n\t\t\tfeature: {\n\t\t\t\tdataZoom: {\n\t\t\t\t\tyAxisIndex: false,\n\t\t\t\t\tlabelFormatter,\n\t\t\t\t},\n\t\t\t},\n\t\t}: undefined,\n\t\txAxis: {\n\t\t\tname: xAxisName,\n\t\t\ttype: \'category\',\n\t\t\tdata: xAxisData\n\t\t},\n\t\tyAxis: {\n\t\t\ttype: \'value\',\n\t\t\tname: yAxisName,\n\t\t},\n\t\tdataZoom: isRangeType ? [\n\t\t\t{\n\t\t\t\ttype: \'inside\',\n\t\t\t\tstartValue: startIndex > -1 ? startIndex : undefined,\n\t\t\t\tendValue: endIndex > -1 ? endIndex : undefined,\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: \'slider\',\n\t\t\t\tstartValue: startIndex > -1 ? startIndex : undefined,\n\t\t\t\tendValue: endIndex > -1 ? endIndex : undefined,\n\t\t\t},\n\t\t]: undefined,\n\t\tseries: [\n\t\t\t{\n\t\t\t\tdata: aggregationData.map(item => ({\n\t\t\t\t\tvalue: item.doc_count,\n\t\t\t\t\tname: item.key,\n\t\t\t\t})),\n\t\t\t\ttype: \'line\',\n\t\t\t},\n\t\t],\n\t};\n}';

ReactiveChart.getOption = function (_ref) {
	var chartType = _ref.chartType,
	    chartConfig = _objectWithoutProperties(_ref, ['chartType']);

	// eslint-disable-next-line
	var chartConfigMethod = eval(ReactiveChart.getOptionAsString(chartType));
	if (chartConfig) {
		return chartConfigMethod(chartConfig);
	}
	return null;
};

ReactiveChart.getOptionAsString = function (chartType) {
	switch (chartType) {
		case ChartTypes.Scatter:
			return ReactiveChart.GetScatterChartOptions;
		case ChartTypes.Line:
			return ReactiveChart.GetLineChartOptions;
		case ChartTypes.Bar:
			return ReactiveChart.GetBarChartOptions;
		case ChartTypes.Pie:
			return ReactiveChart.GetPieChartOptions;
		case ChartTypes.Histogram:
			return ReactiveChart.GetHistogramChartOptions;
		default:
			return null;
	}
};

ReactiveChart.defaultRangeQuery = function (value, props) {
	var query = null;
	if (Array.isArray(value) && value.length) {
		query = (0, _utils.getRangeQueryWithNullValues)(value, props);
	}

	if (query && props.nestedField) {
		return {
			nested: {
				path: props.nestedField,
				query: query
			}
		};
	}

	return query;
};
ReactiveChart.propTypes = {
	// UI props
	filterLabel: _types2.default.string,
	// events
	onClick: _propTypes.func,
	onDblClick: _propTypes.func,
	onMouseDown: _propTypes.func,
	onMouseUp: _propTypes.func,
	onMouseMove: _propTypes.func,
	onMouseOut: _propTypes.func,
	onGlobalOut: _propTypes.func,
	onContextMenu: _propTypes.func,
	beforeValueChange: _propTypes.func,
	onDataZoom: _propTypes.func,
	// ---- user props ---
	// props to configure query
	componentId: _types2.default.stringRequired,
	URLParams: _types2.default.bool,
	dataField: _types2.default.stringRequired,
	showFilter: _types2.default.bool,
	customQuery: _types2.default.func,
	defaultQuery: _types2.default.func,
	react: _types2.default.react,
	size: _types2.default.number,
	index: _types2.default.string,
	queryFormat: _types2.default.queryFormatSearch,
	range: _types2.default.range,
	type: (0, _propTypes.oneOf)(['term', 'range', 'search', 'geo', 'suggestion']),
	// eslint-disable-next-line
	value: _propTypes.any,
	// props to configure chart
	chartType: (0, _propTypes.oneOf)(Object.values(ChartTypes)),
	setOption: _propTypes.func,
	title: _types2.default.string,
	useAsFilter: _types2.default.bool,
	labelFormatter: _types2.default.func,
	xAxisName: _types2.default.string,
	yAxisName: _types2.default.string,
	xAxisField: _types2.default.string,
	yAxisField: _types2.default.string,
	// ---------//
	loader: _types2.default.title,
	onError: _types2.default.func,
	renderError: _types2.default.title,
	onChange: _types2.default.func,
	// redux props
	setQueryOptions: _types2.default.funcRequired,
	watchComponent: _types2.default.funcRequired,
	updateQuery: _types2.default.funcRequired,
	options: _types2.default.options,
	rawData: _types2.default.rawData,
	hits: _types2.default.hits,
	selectedValue: _types2.default.selectedValue,
	setCustomQuery: _types2.default.funcRequired,
	isLoading: _types2.default.bool,
	error: _types2.default.title,
	endpoint: _types2.default.endpoint
};

ReactiveChart.defaultProps = {
	useAsFilter: true,
	chartType: 'custom'
};

// Add componentType for SSR
ReactiveChart.componentType = _constants.componentTypes.multiList;

var mapStateToProps = function mapStateToProps(state, props) {
	return {
		options: props.nestedField && state.aggregations[(0, _transform.getInternalComponentID)(props.componentId)] ? state.aggregations[(0, _transform.getInternalComponentID)(props.componentId)].reactivesearch_nested : state.aggregations[(0, _transform.getInternalComponentID)(props.componentId)],
		hits: state.hits[(0, _transform.getInternalComponentID)(props.componentId)] && state.hits[(0, _transform.getInternalComponentID)(props.componentId)].hits,
		rawData: state.rawData[(0, _transform.getInternalComponentID)(props.componentId)],
		selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
		isLoading: getLoading(state.isLoading[(0, _transform.getInternalComponentID)(props.componentId)]),
		error: state.error[(0, _transform.getInternalComponentID)(props.componentId)]
	};
};

var mapDispatchtoProps = function mapDispatchtoProps(dispatch) {
	return {
		watchComponent: function watchComponent(component, react) {
			return dispatch((0, _actions.watchComponent)(component, react));
		},
		setCustomQuery: function setCustomQuery(component, query) {
			return dispatch((0, _actions.setCustomQuery)(component, query));
		},
		setDefaultQuery: function setDefaultQuery(component, query) {
			return dispatch((0, _actions.setDefaultQuery)(component, query));
		},
		setQueryOptions: function setQueryOptions(component, props, execute) {
			return dispatch((0, _actions.setQueryOptions)(component, props, execute));
		},
		updateQuery: function updateQuery(updateQueryObject, execute, setInternalValue) {
			return dispatch((0, _actions.updateQuery)(updateQueryObject, execute, setInternalValue));
		}
	};
};

var ConnectedComponent = (0, _utils.connect)(mapStateToProps, mapDispatchtoProps)(function (props) {
	return _react2.default.createElement(ReactiveChart, _extends({ ref: props.myForwardedRef }, props));
});

// eslint-disable-next-line
var ForwardRefComponent = _react2.default.forwardRef(function (props, ref) {
	return _react2.default.createElement(
		_PreferencesConsumer2.default,
		{ userProps: props },
		function (preferenceProps) {
			var type = preferenceProps.type;
			if (!type) {
				if (preferenceProps.chartType === ChartTypes.Scatter) {
					type = 'range';
				}
			}
			var aggregationSize = preferenceProps.aggregationSize;
			if (!aggregationSize) {
				if (!type || type === 'term') {
					aggregationSize = preferenceProps.size;
				}
			}

			var size = preferenceProps.size;
			if (preferenceProps.chartType === ChartTypes.Scatter) {
				size = 10;
			}
			var dataField = preferenceProps.dataField;
			if (preferenceProps.chartType === ChartTypes.Scatter) {
				if (!dataField) {
					dataField = '_default';
				}
			}
			return _react2.default.createElement(
				_ComponentWrapper2.default,
				_extends({}, preferenceProps, {
					type: type,
					internalComponent: true,
					componentType: _constants.componentTypes.reactiveChart,
					showHistogram: preferenceProps.chartType === ChartTypes.Scatter ? false : type === 'range',
					setReact: false,
					aggregationSize: aggregationSize,
					size: size,
					dataField: dataField
				}),
				function (componentProps) {
					return _react2.default.createElement(ConnectedComponent, _extends({}, preferenceProps, {
						size: size,
						type: type,
						aggregationSize: aggregationSize,
						dataField: dataField,
						myForwardedRef: ref
					}, componentProps));
				}
			);
		}
	);
});
(0, _hoistNonReactStatics2.default)(ForwardRefComponent, ReactiveChart);

ForwardRefComponent.displayName = 'ReactiveChart';
exports.default = ForwardRefComponent;